{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Embedded systems and hardware design projects by L\u00e1z\u00e1r S\u00e1ndor","text":"<p>This site is a collection of electronics and embedded systems reference designs. It provides schematics, PCB layouts, and documentation for various projects, intended as a resource for learning, experimentation, and future development.</p>"},{"location":"#projects","title":"Projects","text":"BreadboardPSU <p>Solderless breadboard compatible PSU</p> AIODuino <p>ATmega1284P Dev board with peripherals</p> NanoPSU <p>BLE enabled Programmable PSU</p> Launchy <p>ESP-NOW based model rocket launch controller</p> Sparky <p>???</p> TinyPSU <p>Small form factor CV/CC benchtop power supply</p> USB3.0 Hub <p>USB-C IN 2xUSB-C 3.0, 2xUSB-A 3.0 OUT</p> Electronic Load <p>Adjustable Water Cooled Electronic Load</p> BreadboardPSU <p>Solderless breadboard compatible PSU</p> AIODuino <p>ATmega1284P Dev board with peripherals</p> NanoPSU <p>BLE enabled Programmable PSU</p> Launchy <p>ESP-NOW based model rocket launch controller</p> Sparky <p>???</p> TinyPSU <p>Small form factor CV/CC benchtop power supply</p> USB3.0 Hub <p>USB-C IN 2xUSB-C 3.0, 2xUSB-A 3.0 OUT</p> Electronic Load <p>Adjustable Water Cooled Electronic Load</p>"},{"location":"#gallery","title":"Gallery","text":""},{"location":"#downloads","title":"Downloads","text":"<p>AIOduino.zip NANOPSU.zip BreadboardPSU Launchy.zip </p>"},{"location":"#welcome-to-lzr-systems","title":"Welcome to LZR Systems","text":"<p> Tags</p>"},{"location":"Downloads/","title":"NANOPSU","text":"<p>NANOPSU.zip <pre><code>git clone https://github.com/sanko0112/NANOPSU.git\ncd NANOPSU\n</code></pre></p>"},{"location":"Downloads/#launchy","title":"Launchy","text":"<p>Launchy.zip <pre><code>git clone https://github.com/sanko0112/Launchy.git\ncd Launchy\n</code></pre></p>"},{"location":"Downloads/#aioduino","title":"AIOduino","text":"<p>AIOduino.zip <pre><code>git clone https://github.com/sanko0112/AIOduino.git\ncd AIOduino\n</code></pre></p>"},{"location":"Downloads/#breadboardpsu","title":"BreadboardPSU","text":"<p>BreadboardPSU.zip</p> <pre><code>git clone https://github.com/sanko0112/BreadboardPSU.git\ncd BreadboardPSU\n</code></pre>"},{"location":"Gallery/","title":"Gallery","text":""},{"location":"Gallery/#launchy","title":"Launchy","text":""},{"location":"Gallery/#aioduino","title":"AIOduino","text":""},{"location":"Gallery/#breadboardpsu","title":"BreadboardPSU","text":""},{"location":"Gallery/#nanopsu","title":"NANOPSU","text":""},{"location":"Tags/","title":"Tags","text":""},{"location":"Tags/#tag:attiny85","title":"ATtiny85","text":"<ul> <li>            Sparky          </li> </ul>"},{"location":"Tags/#tag:avr","title":"AVR","text":"<ul> <li>            AIODuino          </li> </ul>"},{"location":"Tags/#tag:avr-assembly","title":"AVR Assembly","text":"<ul> <li>            AIODuino          </li> </ul>"},{"location":"Tags/#tag:altium","title":"Altium","text":"<ul> <li>            AIODuino          </li> <li>            BreadboardPSU          </li> <li>            NANOPSU          </li> </ul>"},{"location":"Tags/#tag:arduino-ide","title":"Arduino IDE","text":"<ul> <li>            AIODuino          </li> <li>            Launchy          </li> </ul>"},{"location":"Tags/#tag:cc","title":"C/C++","text":"<ul> <li>            AIODuino          </li> <li>            BreadboardPSU          </li> <li>            Launchy          </li> <li>            NANOPSU          </li> </ul>"},{"location":"Tags/#tag:cubeide","title":"CubeIDE","text":"<ul> <li>            BreadboardPSU          </li> <li>            NANOPSU          </li> </ul>"},{"location":"Tags/#tag:dev-board","title":"Dev-board","text":"<ul> <li>            AIODuino          </li> </ul>"},{"location":"Tags/#tag:esp32","title":"ESP32","text":"<ul> <li>            Launchy          </li> </ul>"},{"location":"Tags/#tag:kicad","title":"KiCad","text":"<ul> <li>            Launchy          </li> </ul>"},{"location":"Tags/#tag:mplabx","title":"MPLABX","text":"<ul> <li>            AIODuino          </li> </ul>"},{"location":"Tags/#tag:pcb","title":"PCB","text":"<ul> <li>            AIODuino          </li> <li>            BreadboardPSU          </li> <li>            Launchy          </li> <li>            NANOPSU          </li> <li>            Sparky          </li> </ul>"},{"location":"Tags/#tag:psu","title":"PSU","text":"<ul> <li>            BreadboardPSU          </li> <li>            NANOPSU          </li> </ul>"},{"location":"Tags/#tag:stm32","title":"STM32","text":"<ul> <li>            BreadboardPSU          </li> <li>            NANOPSU          </li> </ul>"},{"location":"Tags/#tag:","title":"\ud83d\ude80","text":"<ul> <li>            Launchy          </li> </ul>"},{"location":"Projects/","title":"Projects","text":"<ul> <li> <p>ATmega1284P based Dev board with perepherals.    </p> </li> <li> <p></p> <p>BLE enabled Programmable power supply.    </p> </li> <li> <p></p> <p>Solderless breadboard compatible PSU.      </p> </li> <li> <p></p> <p>ESP-NOW based model rocket launch controller</p> </li> <li> <p></p> <p>???</p> </li> <li> <p></p> <p>Small form factor CV/CC benchtop power supply</p> </li> <li> <p></p> <p>USB-C IN 2xUSB-C 3.0, 2xUSB-A 3.0 OUT</p> </li> <li> <p></p> <p>Adjustable Water Cooled Electronic Load</p> </li> </ul>"},{"location":"Projects/AIOduino/","title":"AIODuino","text":"AIODuino is an ATmega1284P-based development board with built-in peripherals for embedded projects. It combines common hardware modules into a single board, making it easy to prototype and test firmware without external shields.","tags":["PCB","Altium","AVR","Dev-board","C/C++","AVR Assembly","Arduino IDE","MPLABX"]},{"location":"Projects/AIOduino/#features","title":"Features","text":"<ul> <li>Microcontroller: ATmega1284P-AU (40 GPIO, 16 KB SRAM, 128 KB Flash)</li> <li>Peripherals onboard:</li> <li>4-digit 7-segment LED display</li> <li>0.96\" OLED display (SSD1306-I\u00b2C)</li> <li>Potentiometer</li> <li>Piezo buzzer</li> <li>4 push buttons + reset button</li> <li>4 Color LEDs + UART indicator LEDs</li> <li>WS2812B addressable RGB LED</li> <li>Interfaces:</li> <li>Dual 2\u00d710 pin headers for expansion</li> <li>USB connector (power + UART bridge)</li> <li>Clock: 16 MHz crystal</li> <li>Power: 5 V via USB or external supply</li> <li>Onboard 3.3V LDO</li> </ul>","tags":["PCB","Altium","AVR","Dev-board","C/C++","AVR Assembly","Arduino IDE","MPLABX"]},{"location":"Projects/AIOduino/#hardware","title":"Hardware","text":"","tags":["PCB","Altium","AVR","Dev-board","C/C++","AVR Assembly","Arduino IDE","MPLABX"]},{"location":"Projects/AIOduino/#schematics","title":"Schematics","text":"<p>Keybinds</p> <ul> <li>Select <code>LMB</code></li> <li>Zoom In/Out <code>Scroll</code></li> <li>Pan <code>RMB Drag</code></li> <li>Reset View <code>R</code></li> </ul>","tags":["PCB","Altium","AVR","Dev-board","C/C++","AVR Assembly","Arduino IDE","MPLABX"]},{"location":"Projects/AIOduino/#pcb","title":"PCB","text":"<p>Keybinds</p> <ul> <li>Select <code>LMB</code></li> <li>Zoom In/Out <code>Scroll</code></li> <li>Pan <code>RMB Drag</code></li> <li>Rotate in 3D <code>LMB Drag</code></li> <li>Reset View <code>R</code></li> <li>Switch to 2D <code>2</code></li> <li>Switch to 3D <code>3</code></li> <li>Next / Previous Layer <code>+/-</code></li> <li>Fold / Unfold in 3D (rigid-flex) <code>5</code></li> <li>Flip Board Top / Bottom <code>F</code></li> </ul>","tags":["PCB","Altium","AVR","Dev-board","C/C++","AVR Assembly","Arduino IDE","MPLABX"]},{"location":"Projects/AIOduino/#credits","title":"Credits","text":"<p>This project uses the MightyCore Arduino core by MCUdude for uploading code on the board</p>","tags":["PCB","Altium","AVR","Dev-board","C/C++","AVR Assembly","Arduino IDE","MPLABX"]},{"location":"Projects/AIOduino/#examples","title":"Examples","text":"<p>Currently waiting for the board to arrive, I'll try to make examples in AVR-C as soon as it arrives.</p>","tags":["PCB","Altium","AVR","Dev-board","C/C++","AVR Assembly","Arduino IDE","MPLABX"]},{"location":"Projects/AIOduino/#photos","title":"Photos","text":"","tags":["PCB","Altium","AVR","Dev-board","C/C++","AVR Assembly","Arduino IDE","MPLABX"]},{"location":"Projects/AIOduino/#downloads","title":"Downloads","text":"<p>AIOduino.zip <pre><code>git clone https://github.com/sanko0112/AIOduino.git\ncd AIOduino\n</code></pre></p>","tags":["PCB","Altium","AVR","Dev-board","C/C++","AVR Assembly","Arduino IDE","MPLABX"]},{"location":"Projects/BreadboardPSU/","title":"BreadboardPSU","text":"BreadboardPSU is a solderless breadboard compatible programmable power supply based on the USB PD PPS protocol.","tags":["PCB","Altium","STM32","PSU","C/C++","CubeIDE"]},{"location":"Projects/BreadboardPSU/#features","title":"Features","text":"<ul> <li>5 Selectable voltage outputs: 3.3V, 5V, 9V, 12V, 16V</li> <li>Single button UI (no jumpers)</li> <li>USB-C input</li> <li>RGB LED feedback</li> <li>Reverse current protection</li> <li>Fully customizable Voltage table and debug via SWIO &amp; UART headers</li> </ul>","tags":["PCB","Altium","STM32","PSU","C/C++","CubeIDE"]},{"location":"Projects/BreadboardPSU/#hardware","title":"Hardware","text":"<p>Microcontroller: CH32V006F8P6</p> <ul> <li>32-bit RISC-V core</li> <li>24MHz internal RC oscillator</li> <li>8kB SRAM</li> <li>62kB PROGMEM</li> <li>8 channel 12-bit ADC</li> <li>14 I/O port</li> <li>I2C, SPI, UART</li> <li>Debug: 1-wire SWIO</li> <li>Package: TSSOP-20</li> </ul> <p>USB PD Sink Controller: CH224Q</p> <ul> <li>USB PD 3.0/3.2, EPR, PPS, SPR</li> <li>100W(PD 3.0), 140W(PD 3.2)</li> <li>Config: <ul> <li>400kHz I2C</li> <li>Single resistor on CFG1 pin</li> <li>CFG1/2/3 logic-level selection</li> </ul> </li> <li>Over-voltage protection</li> </ul> <p>Dual PMV20XNER NMOS for reverse current protection &amp; Vout EN</p> <p>DCP3601NMR Buck converter for MCU power/logic rail</p> <p>CLMUD-FKC RGB LED</p> <p>2x 2x05 2.54 pitch header for breadboard connection</p>","tags":["PCB","Altium","STM32","PSU","C/C++","CubeIDE"]},{"location":"Projects/BreadboardPSU/#schematics","title":"Schematics","text":"<p>Keybinds</p> <ul> <li>Select <code>LMB</code></li> <li>Zoom In/Out <code>Scroll</code></li> <li>Pan <code>RMB Drag</code></li> <li>Reset View <code>R</code></li> </ul>","tags":["PCB","Altium","STM32","PSU","C/C++","CubeIDE"]},{"location":"Projects/BreadboardPSU/#pcb","title":"PCB","text":"<p>Keybinds</p> <ul> <li>Select <code>LMB</code></li> <li>Zoom In/Out <code>Scroll</code></li> <li>Pan <code>RMB Drag</code></li> <li>Rotate in 3D <code>LMB Drag</code></li> <li>Reset View <code>R</code></li> <li>Switch to 2D <code>2</code></li> <li>Switch to 3D <code>3</code></li> <li>Next / Previous Layer <code>+/-</code></li> <li>Fold / Unfold in 3D (rigid-flex) <code>5</code></li> <li>Flip Board Top / Bottom <code>F</code></li> </ul>","tags":["PCB","Altium","STM32","PSU","C/C++","CubeIDE"]},{"location":"Projects/BreadboardPSU/#quick-start","title":"Quick start","text":"<p>\u2757Disclaimer: Breadboards have limited current capacity. Keep continuous current conservative (e.g., \u2264 1 A per rail unless you know your setup) 1. Plug a USB-C PPS capable charger/power bank into the board 2. Short-press the button to enable/disable the output 3. Long-press the button to cycle outputs: 3.3V \u2192 5V \u2192 9V \u2192 12V \u2192 16V 4. RGB LED indicates state/voltage (see table below):</p> Voltage LED color 3.3 V RED 5 V GREEN 9 V BLUE 12 V CYAN 16 V PINK","tags":["PCB","Altium","STM32","PSU","C/C++","CubeIDE"]},{"location":"Projects/BreadboardPSU/#safety","title":"Safety","text":"<ul> <li>Max theoretical output current: 3A(limited by Tj<sub>FET</sub> )</li> <li>Bench-test with current-limited supply first</li> <li>Breadboard contacts can overheat; watch temperature at &gt; 1 A</li> <li>Device defaults to 3.3V upon loss of power/restart</li> </ul>","tags":["PCB","Altium","STM32","PSU","C/C++","CubeIDE"]},{"location":"Projects/BreadboardPSU/#code","title":"\ud83d\udd1cCode","text":"<p>Still waiting for board, stay tuned</p>","tags":["PCB","Altium","STM32","PSU","C/C++","CubeIDE"]},{"location":"Projects/BreadboardPSU/#photos","title":"Photos","text":"","tags":["PCB","Altium","STM32","PSU","C/C++","CubeIDE"]},{"location":"Projects/BreadboardPSU/#downloads","title":"Downloads","text":"<p>BreadboardPSU.zip</p> <pre><code>git clone https://github.com/sanko0112/BreadboardPSU.git\ncd BreadboardPSU\n</code></pre>","tags":["PCB","Altium","STM32","PSU","C/C++","CubeIDE"]},{"location":"Projects/NANOPSU/","title":"NANOPSU","text":"NANOPSU is a USB PPS based small form factor Voltage source for powering electronics projects. It's using an STM32 WB-series controller for BLE connectivity as main UI. Predefined voltages can be set using the onboard toggle switch.","tags":["PCB","Altium","STM32","PSU","C/C++","CubeIDE"]},{"location":"Projects/NANOPSU/#features","title":"Features","text":"<ul> <li>USB-C PPS</li> <li>BLE Connectivity using the STM32WBA55 \u03bcC</li> <li>Current, Voltage sensing</li> <li>Onboard toggle switch for setting predefined voltages (1.8V, 3.3V, 5V, 9V, 12V, 16V)</li> <li>Small form factor</li> <li>Onboard RGB LED for feedback</li> <li>Reverse current protection</li> <li>OCP, OVP</li> <li>Fully customizable Voltage table and debug via SWD</li> </ul>","tags":["PCB","Altium","STM32","PSU","C/C++","CubeIDE"]},{"location":"Projects/NANOPSU/#hardware","title":"Hardware","text":"<p>Microcontroller: STM32WBA55KGU6</p> <ul> <li>32-bit Arm\u00ae Cortex\u00ae-M33 core with TrustZone\u00ae</li> <li>Up to 100 MHz CPU frequency</li> <li>512 kB Flash memory</li> <li>128 kB SRAM</li> <li>Integrated Bluetooth\u00ae Low Energy 5.3 radio (2 Mbps, LE Audio, long-range, AoX)</li> <li>Security: Arm TrustZone\u00ae, AES, PKA, RNG, SHA, secure boot</li> <li>12-bit ADC up to 16-channels</li> <li>Low-power modes with &lt;1 \u00b5A standby</li> <li>Rich peripherals: I\u00b2C, SPI, USART, LPUART, LPTIM, timers, RTC</li> <li>Debug: SWD, SWO, ETM trace</li> <li>Package: QFN-32</li> </ul> <p>USB PD Sink Controller: AP33772S</p> <ul> <li>USB Power Delivery (PD) 3.0 / 3.1 sink controller</li> <li>Supports Fixed, PPS (Programmable Power Supply), and AVS (Adjustable Voltage Supply) contracts</li> <li>Input voltage range: 3.3V - 24V</li> <li>I\u00b2C interface for voltage/current request and monitoring</li> <li>Integrated protections: OVP, UVP, OCP, OTP</li> <li>Drives back-to-back N-channel MOSFETs for VBUS control (reverse current blocking)</li> <li>Configurable power levels via NVM registers or I\u00b2C commands</li> <li>Package: QW-QFN4040-24</li> </ul> <p>DCP3601NMR Buck converter for \u03bcC power/logic rail</p> <p>CLMUD-FKC RGB LED</p>","tags":["PCB","Altium","STM32","PSU","C/C++","CubeIDE"]},{"location":"Projects/NANOPSU/#schematics","title":"Schematics","text":"<p>Keybinds</p> <ul> <li>Select <code>LMB</code></li> <li>Zoom In/Out <code>Scroll</code></li> <li>Pan <code>RMB Drag</code></li> <li>Reset View <code>R</code></li> </ul>","tags":["PCB","Altium","STM32","PSU","C/C++","CubeIDE"]},{"location":"Projects/NANOPSU/#pcb","title":"PCB","text":"<p>Keybinds</p> <ul> <li>Select <code>LMB</code></li> <li>Zoom In/Out <code>Scroll</code></li> <li>Pan <code>RMB Drag</code></li> <li>Rotate in 3D <code>LMB Drag</code></li> <li>Reset View <code>R</code></li> <li>Switch to 2D <code>2</code></li> <li>Switch to 3D <code>3</code></li> <li>Next / Previous Layer <code>+/-</code></li> <li>Fold / Unfold in 3D (rigid-flex) <code>5</code></li> <li>Flip Board Top / Bottom <code>F</code></li> </ul>","tags":["PCB","Altium","STM32","PSU","C/C++","CubeIDE"]},{"location":"Projects/NANOPSU/#quick-start","title":"Quick start","text":"<ul> <li>Plug into a USB-C PPS capable charger</li> <li>Set output voltage via BLE app or toggle switch</li> <li> <p>RGB LED indicates active voltage preset</p> </li> <li> <p>RGB LED indicates state/voltage (see table below):</p> </li> </ul> Voltage LED color 1.8 V WHITE 3.3 V RED 5 V GREEN 9 V BLUE 12 V CYAN 16 V PINK <p>Still waiting for board, stay tuned</p>","tags":["PCB","Altium","STM32","PSU","C/C++","CubeIDE"]},{"location":"Projects/NANOPSU/#safety","title":"Safety","text":"<ul> <li>Max theoretical output current: 5A (Limited by PD spec)</li> <li>Device defaults to 1.8V upon loss of power/restart</li> </ul>","tags":["PCB","Altium","STM32","PSU","C/C++","CubeIDE"]},{"location":"Projects/NANOPSU/#code","title":"\ud83d\udd1cCode","text":"<p>Still waiting for board, stay tuned</p>","tags":["PCB","Altium","STM32","PSU","C/C++","CubeIDE"]},{"location":"Projects/NANOPSU/#photos","title":"Photos","text":"","tags":["PCB","Altium","STM32","PSU","C/C++","CubeIDE"]},{"location":"Projects/NANOPSU/#downloads","title":"Downloads","text":"<p>NANOPSU.zip <pre><code>git clone https://github.com/sanko0112/NANOPSU.git\ncd NANOPSU\n</code></pre></p>","tags":["PCB","Altium","STM32","PSU","C/C++","CubeIDE"]},{"location":"Projects/launchy/","title":"Launchy","text":"<p>ESP32 ESP-NOW Based model rocket launch controller.</p>","tags":["PCB","KiCad","ESP32","\ud83d\ude80","C/C++","Arduino IDE"]},{"location":"Projects/launchy/#features","title":"Features","text":"<ul> <li>ESP-NOW Long range protocol</li> <li>Multi-layer safety: Key switch, iButton, push button</li> <li>OLED display for status feedback</li> <li>Built in battery charging circuit (TP4056)</li> <li>USB-C for programming/charging</li> <li>Internal 1S / External 2S battery selection for the e-match</li> <li>Continuity test (1S mode)</li> <li>Preheat mode(1S mode)</li> <li>Configurabe Countdown time, Ignition time</li> </ul>","tags":["PCB","KiCad","ESP32","\ud83d\ude80","C/C++","Arduino IDE"]},{"location":"Projects/launchy/#hardware","title":"Hardware","text":"<p>\u00a0\u00a0\u00a0\u00a0\u00a0The system is based on a custom PCB designed in KiCad, built around the ESP32-C3-MINI-1 module. Both the transmitter and the igniter/receiver use the same board design, but are populated with different component sets depending on their role. The hardware integrates Li-Ion charging (TP4056), a 3.3 V LDO regulator (AP2112K), a MOSFET-driven relay interface, iButton authentication, and status LEDs. USB-C is provided for charging and programming, while screw terminals allow safe connection of the igniter circuit.</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0Complete manufacturing files are available as a ZIP inside the GERBER folder as well as the BoM. Symbol and footprint libraries are uploaded so the project should be fully editable in KiCad now.</p>","tags":["PCB","KiCad","ESP32","\ud83d\ude80","C/C++","Arduino IDE"]},{"location":"Projects/launchy/#schematic","title":"Schematic","text":"","tags":["PCB","KiCad","ESP32","\ud83d\ude80","C/C++","Arduino IDE"]},{"location":"Projects/launchy/#firmware","title":"Firmware","text":"","tags":["PCB","KiCad","ESP32","\ud83d\ude80","C/C++","Arduino IDE"]},{"location":"Projects/launchy/#transmitterino","title":"Transmitter.ino","text":"<ul> <li>Handles the remote unit (user interface + iButton authentication).</li> <li>Implements menus for:<ul> <li>Battery type selection</li> <li>Continuity check</li> <li>Countdown time</li> <li>Preheat start time</li> <li>Preheat duration</li> <li>Ignition delta</li> </ul> </li> <li>Uses ESP-NOW to send launch and continuity test commands</li> <li>Provides OLED display feedback via LaunchDisplayLibrary</li> <li>Requires valid iButton for arming and launch</li> </ul> Transmitter.ino<pre><code>#include &lt;Arduino.h&gt;\n#include &lt;esp_now.h&gt;\n#include &lt;WiFi.h&gt;\n#include &lt;OneWire.h&gt;\n#include &lt;LaunchDisplayLibrary.h&gt;\n#include &lt;esp_wifi.h&gt;\n\n//defines\n#define iButton 3\n#define togglesw 0\n#define GREEN_LED 5\n#define RED_LED 6\n\nuint8_t launch_code;\nint session_id;\n\nuint8_t broadcastAddress[] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF}; // Igniter MAC-Address here\n\n//iButton read declarations\nOneWire ds(iButton);\nbyte storedID[8];\nbyte allowedID[8] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77}; // iButton fob ID here\n\nuint8_t EN; // EN flag\n\nesp_now_peer_info_t peerInfo;\n\nuint8_t countdownTime = 5;\nconst int T_minValue = 3;\nconst int T_maxValue = 20;\nbool countdown_confirmed = false;\n\nuint8_t preheatStartTime = 3;\nconst int P_SminValue = 1;\nint P_SmaxValue = 5;\nbool preheat_start_confirmed = false;\n\nfloat preheatDuration = 0.25;\nconst float durationResolution = 0.25;\nconst float P_DminValue = 0.25;\nfloat P_DmaxValue = 5.0;\nbool preheat_confirmed = false;\n\nuint8_t ignitionDelta = 5;\nconst int I_DminValue = 1;\nconst int I_DmaxValue = 10;\nbool ignitionDelta_confirmed = false;\n\nuint8_t batt_type = 1;\nbool batt_confirmed = false;\n\ntypedef struct struct_message {\nuint8_t packet_type;\nuint8_t batt_type;\nuint8_t launch_code;\nuint8_t countdownTime;\nuint8_t preheatStartTime;\nfloat preheatDuration;\nfloat durationResolution;\nuint8_t ignitionDelta;\nint session_id;\n} struct_message;\n\nstruct_message LaunchConfig;\n\ntypedef struct {\n  uint8_t packet_type;\n  bool continuity_result;\n} continuity_response_t;\n\n#define PACKET_TYPE_LAUNCH     0\n#define PACKET_TYPE_CONTINUITY 1\n\nuint8_t continuityTest_init = 5;\nbool continuity_result = false;\nbool recvFlag = false;\n//function prototypes\nvoid OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status);\nvoid HandleSingleButton(void (*onShortPress)(), void (*onLongPress)());\nvoid WaitForLaunchConfirm();\nvoid iButtonAuth();\nvoid blink(uint8_t pin, uint16_t times, uint16_t ms);\nvoid reverseblink(uint8_t pin, uint16_t times, uint16_t ms);\nvoid auth();\n\nvoid setup() {\n\n  Serial.begin(115200);\n  Wire.begin(7, 8);\n  u8g2.begin();\n  delay(20);\n  u8g2.clearBuffer();\n  u8g2.sendBuffer();\n  pinMode(GREEN_LED, OUTPUT); // Green_LED indicator\n  pinMode(RED_LED, OUTPUT); // RED_LED indicator\n  pinMode(togglesw, INPUT_PULLDOWN); // Toggle switch as input\n\n  WiFi.mode(WIFI_STA);\n  esp_wifi_set_protocol(WIFI_IF_STA, WIFI_PROTOCOL_LR);  // Long Range mode\n\n  // Initilize ESP-NOW\n  if (esp_now_init() != ESP_OK) {\n    Serial.println(\"Error initializing ESP-NOW\");\n    return;\n  }\n\n  // Register the send callback\n  // In setup() or once before any send\n  esp_now_register_recv_cb(OnDataRecv);\n\n  // Register peer\n  memcpy(peerInfo.peer_addr, broadcastAddress, 6);\n  peerInfo.channel = 0;  \n  peerInfo.encrypt = false;\n  draw_welcome();\n  delay(500);\n  loading();\n}\n\nvoid loop() {\n  //checking for valid ibutton\n  auth();\n  delay(10);\n  //valid ibutton found\n  if(EN){\n\n    digitalWrite (RED_LED, LOW);\n    digitalWrite (GREEN_LED, HIGH);\n    draw_auth_success();\n    delay(500);\n\n    //adding ESP-NOW peer\n    if (!esp_now_is_peer_exist(broadcastAddress)) {\n      if (esp_now_add_peer(&amp;peerInfo) != ESP_OK) {\n        Serial.println(\"Failed to add peer\");\n        return;\n      }\n      else{\n        Serial.println(\" added peer\");\n    }\n    }\n    delay(100);\n    openBatteryTypeMenu();\n    delay(300);\n    if (batt_type == 1)\n    { \n    continuity();\n    s_settings();\n    }\n    else\n    {\n      ss_settings();\n    }\n    draw_armed();\n    LaunchConfig.packet_type = PACKET_TYPE_LAUNCH;\n    launch_code = 33;\n    session_id = rand();\n    LaunchConfig.launch_code = launch_code;\n    LaunchConfig.batt_type = batt_type;\n    LaunchConfig.countdownTime = countdownTime;\n    LaunchConfig.preheatStartTime = preheatStartTime;\n    LaunchConfig.preheatDuration = preheatDuration;\n    LaunchConfig.durationResolution = durationResolution;\n    LaunchConfig.ignitionDelta = ignitionDelta;\n    LaunchConfig.session_id = session_id;\n    delay(2000);\n    //Waiting for button press\n    WaitForLaunchConfirm();\n    //sending launch command\n\n    for(int j = 0; j&lt;3; j++){\n      LaunchConfig.packet_type = PACKET_TYPE_LAUNCH;\n      esp_now_send(broadcastAddress, (uint8_t *)&amp;LaunchConfig, sizeof(LaunchConfig));\n    }\n    //starting countdown\n    countdown(countdownTime,preheatStartTime,preheatDuration);\n    draw_ignition();\n    delay(10);\n    delay(ignitionDelta*1000);\n    esp_now_del_peer(broadcastAddress); // Optional: prevent re-use until re-auth\n    digitalWrite (GREEN_LED, LOW);\n    delay(20);\n    digitalWrite (RED_LED, HIGH);\n    EN = 0;\n  }\n  //ibutton auth failed retrying...\n  else{\n    auth();\n  }\n}\n\n\nvoid iButtonAuth()\n{\n  //initializing\n  byte addr[8];\n  if (!ds.search(addr)) {\n    ds.reset_search();\n    return;\n  }\n  //checking iButton type\n  if (OneWire::crc8(addr, 7) != addr[7]) {\n    Serial.println(\"CRC is not valid!\");\n    return;\n  }\n  //storing recieved ID\n  for (int i = 0; i &lt; 8; i++) {\n    storedID[i] = addr[i];\n  }\n  //checking if recieved ID is matching the stored ID\n  bool isAuth = true;\n  for (int i = 0; i &lt; 8; i++) {\n    if (storedID[i] != allowedID[i]) {\n      isAuth = false;\n    }\n  }\n  //matching ID EN flag TRUE\n  if (isAuth) {\n    Serial.println(\" -&gt; AUTHORIZED\");\n    EN = 1;\n  }\n  //mismatch on ID's EN flag stays FALSE\n  else {\n    Serial.println(\"FAILED\");\n    reverseblink(RED_LED, 2, 200);\n    EN = 0;\n  }\n  delay(200);\n}\n\nvoid HandleSingleButton(void (*onShortPress)(), void (*onLongPress)()) {\n  const unsigned long longPressTime = 1000; // 1 second hold\n  unsigned long pressStart = 0;\n  bool isPressed = false;\n  bool longPressTriggered = false;\n\n  while (true) {\n    int state = digitalRead(togglesw);\n\n    if (state == HIGH) {\n      if (!isPressed) {\n        pressStart = millis();\n        isPressed = true;\n      } else if (!longPressTriggered &amp;&amp; (millis() - pressStart &gt;= longPressTime)) {\n        longPressTriggered = true;\n        onLongPress();  // Immediately trigger long press\n        break;\n      }\n    } else if (state == LOW &amp;&amp; isPressed) {\n      // Button released before long press time\n      if (!longPressTriggered) {\n        onShortPress();  // Short press handler\n      }\n      break;\n    }\n\n    delay(10);\n  }\n}\n\nvoid WaitForLaunchConfirm() {\n  Serial.println(\"Hold to launch...\");\n  HandleSingleButton([]() {}, []() {\n    Serial.println(\"Launch confirmed.\");\n    // Proceed with countdown + ignition\n  });\n}\n\nvoid blink(uint8_t pin, uint16_t times, uint16_t ms)\n{\n  for (uint16_t i = 0; i&lt; times; i++){\n    digitalWrite(pin, HIGH);\n    delay(ms);\n    digitalWrite(pin, LOW);\n    delay(ms);\n  }\n}\n\nvoid reverseblink(uint8_t pin, uint16_t times, uint16_t ms)\n{\n  for (uint16_t i = 0; i&lt; times; i++){\n    digitalWrite(pin, LOW);\n    delay(ms);\n    digitalWrite(pin, HIGH);\n    delay(ms);\n  }\n}\n\n\nvoid auth()\n{ \n  while(1){\n    draw_auth_a();\n    iButtonAuth();\n    delay(100);\n    draw_auth_b();\n    iButtonAuth();\n    delay(100);\n    draw_auth_c();\n    iButtonAuth();\n    delay(100);\n    if(EN)\n      break;\n    draw_auth_d();\n    iButtonAuth();\n    delay(100);\n    if(EN)\n      break;    \n    draw_auth_e();\n    iButtonAuth();\n    delay(100);\n    if(EN)\n      break;    \n    draw_auth_f();\n    iButtonAuth();\n    delay(100);\n    if(EN)\n      break;    \n    draw_auth_g();\n\n    iButtonAuth();\n    delay(100);\n    if(EN)\n      break;\n  }   \n}\n\nvoid updateCountdownText() {\n  itoa(countdownTime, countdown_menu_var, 10);\n}\n\nvoid onShortPress_CountdownMenu() {\n  countdownTime++;\n  if (countdownTime &gt; T_maxValue) countdownTime = T_minValue;\n  updateCountdownText();\n  draw_countdown_menu();\n}\n\nvoid onLongPress_CountdownMenu() {\n  countdown_confirmed = true;\n  Serial.print(\"Countdown set to: \");\n  Serial.println(countdownTime);\n}\n\nvoid openCountdownMenu() {\n  countdown_confirmed = false;\n  updateCountdownText();\n  draw_countdown_menu();\n\n  while (!countdown_confirmed) {\n    HandleSingleButton(onShortPress_CountdownMenu, onLongPress_CountdownMenu);\n  }\n}\n\n\nvoid updatePreheatStartText() {\n  itoa(preheatStartTime, preheat_start_menu_var, 10);\n}\n\nvoid onShortPress_PreheatStartMenu() {\n  preheatStartTime++;\n  if (preheatStartTime &gt; P_SmaxValue) preheatStartTime = P_SminValue;\n  updatePreheatStartText();\n  draw_preheat_start_menu();\n}\n\nvoid onLongPress_PreheatStartMenu() {\n  preheat_start_confirmed = true;\n  Serial.print(\"Preheat start time set to: T-\");\n  Serial.println(preheatStartTime);\n}\n\nvoid openPreheatStartMenu() {\n  preheat_start_confirmed = false;\n  updatePreheatStartText();\n  draw_preheat_start_menu();\n  delay(400);\n\n  while (!preheat_start_confirmed) {\n    HandleSingleButton(onShortPress_PreheatStartMenu, onLongPress_PreheatStartMenu);\n  }\n}\n\n\nvoid updatePreheatText() {\n  dtostrf(preheatDuration, 3, 2, preheat_duration_menu_var);\n}\n\nvoid onShortPress_PreheatMenu() {\n  preheatDuration += durationResolution;\n  if (preheatDuration &gt; P_DmaxValue) preheatDuration = P_DminValue;\n  updatePreheatText();\n  draw_preheat_duration_menu();\n}\n\nvoid onLongPress_PreheatMenu() {\n  preheat_confirmed = true;\n  Serial.print(\"Preheat set to: \");\n  Serial.println(preheatDuration);\n}\n\nvoid openPreheatDurationMenu() {\n  preheat_confirmed = false;\n  updatePreheatText();\n  draw_preheat_duration_menu();\n  delay(400);\n  while (!preheat_confirmed) {\n    HandleSingleButton(onShortPress_PreheatMenu, onLongPress_PreheatMenu);\n  }\n}\n\nvoid updateIgnitionDeltaText() {\n  itoa(ignitionDelta, ignition_delta_menu_var, 10);\n}\n\nvoid onShortPress_IgnitionMenu() {\n  ignitionDelta++;\n  if (ignitionDelta &gt; I_DmaxValue) ignitionDelta = I_DminValue;\n  updateIgnitionDeltaText();\n  draw_ignition_delta_menu();\n}\n\nvoid onLongPress_IgnitionMenu() {\n  ignitionDelta_confirmed = true;\n  Serial.print(\"Ignition Delta is set to: \");\n  Serial.println(ignitionDelta);\n}\n\nvoid openIgnitionDeltaMenu() {\n  ignitionDelta_confirmed = false;\n  updateIgnitionDeltaText();\n  draw_ignition_delta_menu();\n  delay(400);\n  while (!ignitionDelta_confirmed) {\n    HandleSingleButton(onShortPress_IgnitionMenu, onLongPress_IgnitionMenu);\n  }\n}\n\nvoid s_settings(void)\n{\ndraw_countdown_menu();\ndelay(300);\nopenCountdownMenu();\nP_SmaxValue = countdownTime;\nopenPreheatStartMenu();\nP_DmaxValue = preheatStartTime-0.75;\nopenPreheatDurationMenu();\nopenIgnitionDeltaMenu();\n\nitoa(countdownTime, armed_t_, 10);\nitoa(preheatStartTime, armed_ps, 10);\nitoa(preheatDuration, armed_pd, 10);\nitoa(ignitionDelta, armed_id, 10);\n/*\nint launch_code;\nint countdownTime;\nint preheatStartTime;\nfloat preheatDuration;\nint ignitionDelta;\n*/\n}\nvoid ss_settings(void)\n{\nopenCountdownMenu();\nP_SmaxValue = countdownTime;\nopenIgnitionDeltaMenu();\nitoa(countdownTime, armed_t_, 10);\nitoa(preheatStartTime, armed_ps, 10);\nitoa(preheatDuration, armed_pd, 10);\nitoa(ignitionDelta, armed_id, 10);\n/*\nint launch_code;\nint countdownTime;\nint preheatStartTime;\nfloat preheatDuration;\nint ignitionDelta;\n*/\n}\nvoid OnDataRecv(const esp_now_recv_info_t *recv_info, const uint8_t *incomingData, int len) {\n    if (len == sizeof(continuity_response_t)) {\n        continuity_response_t response;\n        memcpy(&amp;response, incomingData, len);\n        if (response.packet_type == PACKET_TYPE_CONTINUITY) {\n            continuity_result = response.continuity_result;\n            Serial.print(\"Received continuity result: \");\n            Serial.println(continuity_result);\n        }\n    }\n  recvFlag = true;  \n}\n\n\nvoid continuity() {\n\n  Serial.println(\"Press and hold to begin continuity test...\");\n  draw_continuity_check_start();\n  delay(1000);\n  HandleSingleButton([]() {}, []() {\n    Serial.println(\"Continuity test started\");\n\n    struct_message continuity_packet = {};\n    continuity_packet.packet_type = PACKET_TYPE_CONTINUITY;\n    esp_now_send(broadcastAddress, (uint8_t *)&amp;continuity_packet, sizeof(continuity_packet));\n    unsigned long startTime = millis();\n    while ( millis() - startTime &lt; 1500) {\n      delay(10); // yield time for callback\n    }\n        if (continuity_result) {\n          Serial.println(\"Continuity success. Hold to continue...\");\n          draw_continuity_check_success();\n          HandleSingleButton([]() {}, []() {\n          Serial.println(\"Continuing...\");\n          delay(400);\n          });\n        } else {\n          Serial.println(\"Continuity failed. Check connection and retry.\");\n          draw_continuity_check_failed();\n          while(1){}\n         // wait forever or implement retry\n        }\n\n  });\n}\n\n// ===== Battery type menu =====\n// 1S = 1, 2S = 2\n\n\n// Show the right screen for current selection\nvoid draw_batt_current() {\n  if (batt_type == 1) {\n    draw_batt_s();   // your \"1S selected\" screen\n  } else {\n    draw_batt_ss();  // your \"2S selected\" screen\n  }\n}\n\n// Short press: toggle 1S &lt;-&gt; 2S\nvoid onShortPress_BattMenu() {\n  batt_type = (batt_type == 1) ? 2 : 1;\n  draw_batt_current();\n}\n\n// Long press: confirm selection\nvoid onLongPress_BattMenu() {\n  batt_confirmed = true;\n  Serial.print(\"Battery type set to: \");\n  Serial.println(batt_type == 1 ? \"1S\" : \"2S\");\n  Serial.println(batt_type);\n}\n\n// Open the menu and wait for confirmation\nvoid openBatteryTypeMenu() {\n  batt_confirmed = false;\n  draw_batt_current();\n  delay(300);\n\n  while (!batt_confirmed) {\n    HandleSingleButton(onShortPress_BattMenu, onLongPress_BattMenu);\n  }\n}\n</code></pre>","tags":["PCB","KiCad","ESP32","\ud83d\ude80","C/C++","Arduino IDE"]},{"location":"Projects/launchy/#igniterino","title":"Igniter.ino","text":"<ul> <li>Handles the receiver unit (relay + buzzer)</li> <li>Waits for commands over ESP-NOW</li> <li>Performs continuity test by measuring V<sub>drop<sub> <li>Executes countdown, preheat, and ignition relay control</li> <li>Includes buzzer startup sounds and launch feedback</li> Igniter.ino<pre><code>  #include &lt;esp_now.h&gt;\n  #include &lt;WiFi.h&gt;\n  #include &lt;esp_wifi.h&gt;\n\n  // Pin definitions\n  #define RELAY_PIN 2\n  #define BUZZ 3\n  #define ADC_PIN 0\n\n  // Launch code value to match\n  typedef struct struct_message {\n  uint8_t packet_type;\n  uint8_t batt_type;\n  uint8_t launch_code;\n  uint8_t countdownTime;\n  uint8_t preheatStartTime;\n  float preheatDuration;\n  float durationResolution;\n  uint8_t ignitionDelta;\n  int session_id;\n  } struct_message;\n\n  struct_message LaunchConfig;\n\n  int lastSession_id = 4;\n\n  typedef struct {\n  uint8_t packet_type;\n  uint8_t continuity_result;\n  } continuity_response_t;\n\n  uint8_t continuity_result = 0;\n\n  #define PACKET_TYPE_LAUNCH     0\n  #define PACKET_TYPE_CONTINUITY 1\n\n  uint8_t broadcastAddress[] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF}; // Transmitter MAC-Address here\n\n\n  // Setup function\n  void setup() {\n    Serial.begin(115200);\n\n    // Initialize pins\n    pinMode(RELAY_PIN, OUTPUT);\n    pinMode(BUZZ, OUTPUT);\n    digitalWrite(RELAY_PIN, LOW);   // Relay OFF\n    digitalWrite(BUZZ, LOW);  // Buzzer OFF\n\n    // Set WiFi to station mode\n    WiFi.mode(WIFI_STA);\n    esp_wifi_set_protocol(WIFI_IF_STA, WIFI_PROTOCOL_LR);  // Long Range mode\n\n\n    // Initialize ESP-NOW\n    if (esp_now_init() != ESP_OK) {\n      Serial.println(\"Error initializing ESP-NOW\");\n      return;\n    }\n    esp_now_peer_info_t peer;\n    memset(&amp;peer, 0, sizeof(peer));\n    memcpy(peer.peer_addr, broadcastAddress, 6);\n    peer.channel = 0;\n    peer.encrypt = false;\n\n    if (!esp_now_is_peer_exist(peer.peer_addr)) {\n      esp_err_t addStatus = esp_now_add_peer(&amp;peer);\n    if (addStatus != ESP_OK) {\n      Serial.println(\"Failed to add transmitter as peer!\");\n  }\n}\n    // Register receive callback\n    esp_now_register_recv_cb(OnDataRecv);\n    Serial.println(\"Receiver ready. Waiting for peer auth and launch command...\");\n    startup_sound();\n  }\n\n  // Loop does nothing, waiting for data via callback\n  void loop() {\n    delay(10);\n  }\n\n  // Callback function when data is received\nvoid OnDataRecv(const esp_now_recv_info_t *recv_info, const uint8_t *incomingData, int len) {\n  struct_message msg;\n  memcpy(&amp;msg, incomingData, sizeof(msg));\n  if (msg.packet_type == PACKET_TYPE_CONTINUITY) {\n    int adcVal = 0;\n    int freeValue = 5000;\n    int loadValue = 5000;\n    for (int q = 0; q&lt;5; q++)\n    {\n      adcVal = analogRead(ADC_PIN);\n      if (adcVal &lt; freeValue){\n        freeValue = adcVal;\n      }\n      delay(20);\n    }\n    digitalWrite(RELAY_PIN, HIGH);\n    for(int p = 0; p&lt;10;p++)\n    {\n      adcVal = analogRead(ADC_PIN);\n      if (adcVal &lt; loadValue){\n        loadValue = adcVal;\n      }\n      delay(50);\n    }\n    digitalWrite(RELAY_PIN, LOW);\n    Serial.println(\"freeValue\");\n    Serial.println(freeValue);\n    Serial.println(\"loadValue\");\n    Serial.println(loadValue);\n    if(loadValue&lt;=freeValue-20)\n    {\n      continuity_result = true;\n    }\n    else\n    {\n      continuity_result = false;\n    }\n    continuity_response_t response;\n    response.packet_type = PACKET_TYPE_CONTINUITY;\n    response.continuity_result = continuity_result;\n\n    for (int k = 0; k &lt; 5; k++) {\n      esp_now_send(broadcastAddress, (uint8_t *)&amp;response, sizeof(response));\n    }\n    Serial.println(continuity_result);\n    if (continuity_result)\n    {\n       onReceive_sound(2);\n    }\n    else{fail_sound();}\n    delay(100);\n  }\n  if (msg.packet_type == PACKET_TYPE_LAUNCH &amp;&amp; msg.session_id != lastSession_id) {\n    lastSession_id = msg.session_id;\n    LaunchConfig = msg;\n    uint8_t batteryType;\n    batteryType = LaunchConfig.batt_type;\n    Serial.println(batteryType);\n    if (batteryType == 1) {\n      TickType_t lastWakeTime = xTaskGetTickCount();\n      int durationResolution_ms = LaunchConfig.durationResolution * 1000;\n      int preheatDuration_ms = LaunchConfig.preheatDuration * 1000;\n      int preheatStart_ms = LaunchConfig.preheatStartTime * 1000;\n      int countdown_ms = LaunchConfig.countdownTime * 1000-250;     //countdown-onReceive_sound\n      onReceive_sound(5);\n      if (LaunchConfig.launch_code == 33) {\n        for (int t = countdown_ms; t &gt;= 0; t -= durationResolution_ms) {\n        // Start preheat when time left &lt;= preheatStart and there's preheat duration remaining\n          if (t &lt;= preheatStart_ms &amp;&amp; preheatDuration_ms &gt; 0) {\n          digitalWrite(RELAY_PIN, HIGH);  // Relay ON (preheat)\n          digitalWrite(BUZZ, HIGH);\n          preheatDuration_ms -= durationResolution_ms;\n          } else {\n          digitalWrite(RELAY_PIN, LOW); // Relay OFF\n          digitalWrite(BUZZ, LOW);\n         }\n\n          vTaskDelayUntil(&amp;lastWakeTime, pdMS_TO_TICKS(durationResolution_ms));\n        }\n\n        // IGNITION PHASE\n        digitalWrite(RELAY_PIN, HIGH);  // Relay ON (ignite)\n        digitalWrite(BUZZ, HIGH);\n        delay(LaunchConfig.ignitionDelta * 1000);\n        digitalWrite(RELAY_PIN, LOW); // Relay OFF\n        digitalWrite(BUZZ, LOW); // Relay OFF\n      }\n    }\n    else\n    {\n      TickType_t lastWakeTime = xTaskGetTickCount();\n      int countdown_ms = LaunchConfig.countdownTime * 1000-250;\n      int durationResolution_ms = LaunchConfig.durationResolution * 1000;     //countdown-onReceive_sound\n      onReceive_sound(5);\n      if (LaunchConfig.launch_code == 33) {\n        for (int t = countdown_ms; t &gt;= 0; t -= durationResolution_ms) {\n          vTaskDelayUntil(&amp;lastWakeTime, pdMS_TO_TICKS(durationResolution_ms));\n        }\n      }\n      // IGNITION PHASE\n      digitalWrite(RELAY_PIN, HIGH);  // Relay ON (ignite)\n      digitalWrite(BUZZ, HIGH);\n      delay(LaunchConfig.ignitionDelta * 1000);\n      digitalWrite(RELAY_PIN, LOW); // Relay OFF\n      digitalWrite(BUZZ, LOW); // Relay OFF\n    }\n  }\n}\n void startup_sound()\n{\n    digitalWrite(BUZZ, HIGH);\n    delay(300);\n    digitalWrite(BUZZ, LOW);\n    delay(300);\n    digitalWrite(BUZZ, HIGH);\n    delay(75);\n    digitalWrite(BUZZ, LOW);\n    delay(75);\n    digitalWrite(BUZZ, HIGH);\n    delay(75);\n    digitalWrite(BUZZ, LOW);\n    delay(75);\n}\n  void onReceive_sound(int times)\n  {\n    for(int i = 0; i &lt; times; i++)\n    {\n    digitalWrite(BUZZ, HIGH);\n    delay(50);\n    digitalWrite(BUZZ, LOW);\n    delay(50);\n    }\n  }\nvoid fail_sound()\n{\n    digitalWrite(BUZZ, HIGH);\n    delay(300);\n    digitalWrite(BUZZ, LOW);\n    delay(300);\n    digitalWrite(BUZZ, HIGH);\n    delay(300);\n    digitalWrite(BUZZ, LOW);\n    delay(300);\n    digitalWrite(BUZZ, HIGH);\n    delay(300);\n    digitalWrite(BUZZ, LOW);\n    delay(300);\n}\n</code></pre>","tags":["PCB","KiCad","ESP32","\ud83d\ude80","C/C++","Arduino IDE"]},{"location":"Projects/launchy/#launchdisplaylibrary","title":"LaunchDisplayLibrary","text":"<ul> <li>Custom display driver using U8g2 for SH1106 OLED.</li> <li>Provides functions for:<ul> <li>Splash/welcome screen</li> <li>Authentication animations</li> <li>Armed state screen (with T-, P_s, P_d, I_d values)</li> <li>Countdown + preheat visual feedback</li> <li>Ignition screen</li> <li>Menus for parameter selection</li> </ul> </li> </ul>","tags":["PCB","KiCad","ESP32","\ud83d\ude80","C/C++","Arduino IDE"]},{"location":"Projects/launchy/#getmacaddressino","title":"GetMacAddress.ino","text":"<ul> <li>Utility to print the ESP32\u2019s MAC address (used for setting ESP-NOW peers).</li> </ul>","tags":["PCB","KiCad","ESP32","\ud83d\ude80","C/C++","Arduino IDE"]},{"location":"Projects/launchy/#readfobino","title":"ReadFob.ino","text":"<ul> <li>Utility to read and print iButton IDs (used to whitelist authorized keys).</li> </ul>","tags":["PCB","KiCad","ESP32","\ud83d\ude80","C/C++","Arduino IDE"]},{"location":"Projects/launchy/#dependencies","title":"Dependencies","text":"","tags":["PCB","KiCad","ESP32","\ud83d\ude80","C/C++","Arduino IDE"]},{"location":"Projects/launchy/#arduino-core-for-esp32","title":"Arduino Core for ESP32","text":"","tags":["PCB","KiCad","ESP32","\ud83d\ude80","C/C++","Arduino IDE"]},{"location":"Projects/launchy/#libraries","title":"Libraries:","text":"<ul> <li>esp_now.h (built-in)</li> <li>WiFi.h (built-in)</li> <li>esp_wifi.h (for long-range protocol mode)</li> <li>OneWire (for iButton reader)</li> <li>U8g2lib (for OLED display)</li> </ul>","tags":["PCB","KiCad","ESP32","\ud83d\ude80","C/C++","Arduino IDE"]},{"location":"Projects/launchy/#setup-upload","title":"Setup &amp; Upload","text":"<ol> <li>Clone repo/Download as .zip and open in Arduino IDE.</li> <li>Select ESP32 Dev Module (or your ESP32 board).</li> <li>Upload separately:<ul> <li>Transmitter.ino \u2192 Remote unit</li> <li>2.Receiver.ino \u2192 Receiver unit</li> </ul> </li> <li>Use GetMacAddress.ino on each ESP32 to note their MAC addresses.<ul> <li>Update broadcastAddress[] in transmitter/receiver code accordingly.</li> </ul> </li> <li>Use Read_fob.ino to read your iButton ID.<ul> <li>Replace in allowedID[] array in the transmitter code.</li> </ul> </li> </ol>","tags":["PCB","KiCad","ESP32","\ud83d\ude80","C/C++","Arduino IDE"]},{"location":"Projects/launchy/#display-demo","title":"Display demo","text":"","tags":["PCB","KiCad","ESP32","\ud83d\ude80","C/C++","Arduino IDE"]},{"location":"Projects/launchy/#board","title":"Board","text":"","tags":["PCB","KiCad","ESP32","\ud83d\ude80","C/C++","Arduino IDE"]},{"location":"Projects/launchy/#transmitter-enclosure","title":"Transmitter enclosure","text":"","tags":["PCB","KiCad","ESP32","\ud83d\ude80","C/C++","Arduino IDE"]},{"location":"Projects/launchy/#igniter-enclosure","title":"Igniter enclosure","text":"","tags":["PCB","KiCad","ESP32","\ud83d\ude80","C/C++","Arduino IDE"]},{"location":"Projects/launchy/#photos","title":"Photos","text":"","tags":["PCB","KiCad","ESP32","\ud83d\ude80","C/C++","Arduino IDE"]},{"location":"Projects/launchy/#videos","title":"Videos","text":"","tags":["PCB","KiCad","ESP32","\ud83d\ude80","C/C++","Arduino IDE"]},{"location":"Projects/launchy/#downloads","title":"Downloads","text":"<p>Launchy.zip <pre><code>git clone https://github.com/sanko0112/Launchy.git\ncd Launchy\n</code></pre></p>","tags":["PCB","KiCad","ESP32","\ud83d\ude80","C/C++","Arduino IDE"]}]}